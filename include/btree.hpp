#pragma once

// Заголовочный файл с объявлением структуры данных

namespace itis {
  // Узел BTree
  class BTreeNode {
    int *keys;      // Массив ключей
    int t;          // Минимальная степень
    BTreeNode **C;  // Массив дочерних указателей
    int n;          // Текущее количество ключей
    bool leaf;      // Верно, когда узел является листом, иначе ложь

   public:
    BTreeNode(int _t, bool _leaf);  // Конструктор

    // Функция для обхода всех узлов
    void traverse();

    // Функция для поиска ключа
    BTreeNode *search(int k);  // возвращает nullptr, если k отсутствует.

    // Функция, которая возвращает индекс первого ключа, который больше
    // или равен k
    int findKey(int k);

    // Вспомогательная функция для вставки нового ключа в поддерево,
    // основанное на этом узле. Предполагается, что при вызове
    // этой функции узел должен быть неполным.
    void insertNonFull(int k);

    // Служебная функция для разделения дочернего y этого узла.
    // i - индекс y в дочернем массиве C [].
    // При вызове этой функции дочерний элемент y должен быть заполнен
    void splitChild(int i, BTreeNode *y);

    // Функция-оболочка для удаления ключа k в поддереве,
    // имеющем корень с этим узлом.
    void remove(int k);

    // Функция для удаления ключа, присутствующего в позиции idx
    // в этом узле, который является листом
    void removeFromLeaf(int idx);

    // Функция для удаления ключа, присутствующего в позиции
    // idx в этом узле, который не является конечным узлом
    void removeFromNonLeaf(int idx);

    // Функция для получения предшественника ключа,
    // где ключ находится в позиции idx в узле
    int getPred(int idx);

    // Функция для получения преемника ключа,
    // где ключ находится в позиции idx в узле
    int getSucc(int idx);

    // Функция для заполнения дочернего узла,
    // присутствующего в позиции idx в массиве C [],
    // если этот дочерний узел имеет менее t-1 ключей
    void fill(int idx);

    // Функция, которая заимствует ключ из узла C [idx-1]
    // и помещает его в узел C [idx]
    void borrowFromPrev(int idx);

    // Функция, которая заимствует ключ из узла C [idx + 1]
    // и помещает его в узел C [idx]
    void borrowFromNext(int idx);

    // Функция для объединения idx-го потомка
    // узла с (idx + 1) -ым потомком узла
    void merge(int idx);

    // Сделаем BTree другом этого, чтобы мы могли
    // получить доступ к закрытым членам этого класса в функциях BTree
    friend class BTree;
  };

  class BTree
  {
    BTreeNode *root; // Указатель на корневой узел
    int t;  // Минимальная степень
   public:

    // Конструктор (Инициализирует дерево как пустое)
    BTree(int _t)
    {
      root = nullptr;
      t = _t;
    }

    void traverse()
    {
      if (root != nullptr) root->traverse();
    }

    // функция для поиска ключа в этом дереве
    BTreeNode* search(int k)
    {
      return (root == nullptr)? nullptr : root->search(k);
    }

    // Основная функция, которая вставляет новый ключ в это B-дерево
    void insert(int k);

    // Основная функция, которая удаляет новый ключ в этом B-дереве
    void remove(int k);

  };

}  // namespace itis