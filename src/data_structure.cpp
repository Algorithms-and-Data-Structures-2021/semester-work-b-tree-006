#include<iostream>
#include "data_structure.hpp"

// файл с определениями

namespace itis {

  BTreeNode::BTreeNode(int t1, bool leaf1)
  {
    // Копируем заданную минимальную степень и свойство листа
    t = t1;
    leaf = leaf1;

    // Выделяем память для максимального количества
    // возможных ключей и дочерних указателей
    keys = new int[2*t-1];
    C = new BTreeNode *[2*t];

    // Инициализируем количество ключей как 0
    n = 0;
  }

// Служебная функция, возвращающая индекс первого ключа,
// который больше или равен k
  int BTreeNode::findKey(int k)
  {
    int idx=0;
    while (idx<n && keys[idx] < k)
      ++idx;
    return idx;
  }

// Функция для удаления ключа k из поддерева, имеющего корень с этим узлом
  void BTreeNode::remove(int k)
  {
    int idx = findKey(k);

    // Удаляемый ключ присутствует в этом узле
    if (idx < n && keys[idx] == k)
    {

      // Если узел является листовым, вызывается removeFromLeaf
      // В противном случае вызывается функция removeFromNonLeaf
      if (leaf)
        removeFromLeaf(idx);
      else
        removeFromNonLeaf(idx);
    }
    else
    {

      // Если этот узел является листовым, значит, ключа нет в дереве
      if (leaf)
      {
//        std::cout << "The key "<< k <<" is does not exist in the tree\n";
        return;
      }

      // Удаляемый ключ присутствует в поддереве, имеющем корень с этим узлом
      // Флаг указывает, присутствует ли ключ в поддереве,
      // имеющем корень с последним дочерним элементом этого узла
      bool flag = ( (idx==n)? true : false );

      // Если у дочернего элемента, в котором должен существовать ключ,
      // меньше t ключей, мы заполняем этот дочерний элемент
      if (C[idx]->n < t)
        fill(idx);

      // Если последний дочерний элемент был объединен, он должен быть объединен
      // с предыдущим дочерним элементом, поэтому мы рекурсивно переходим
      // к (idx-1) -ому дочернему элементу. В противном случае мы рекурсивно переходим
      // к (idx) -ому дочернему элементу, который теперь имеет как минимум t ключей
      if (flag && idx > n)
        C[idx-1]->remove(k);
      else
        C[idx]->remove(k);
    }
    return;
  }

// Функция для удаления ключа idx из этого узла, который является листовым узлом
  void BTreeNode::removeFromLeaf (int idx)
  {

    // Перемещаем все ключи после idx-th pos на одну позицию назад
    for (int i=idx+1; i<n; ++i)
      keys[i-1] = keys[i];

    // Уменьшаем количество ключей
    n--;

    return;
  }

// Функция для удаления ключа idx из этого узла, который не является конечным узлом
  void BTreeNode::removeFromNonLeaf(int idx)
  {

    int k = keys[idx];

    // Если дочерний элемент, предшествующий k (C [idx]),
    // имеет как минимум t ключей, найти предшественника 'pred' k
    // в поддереве с корнем C [idx]. Заменить k на пред.
    // Рекурсивно удалить пред в C [idx]
    if (C[idx]->n >= t)
    {
      int pred = getPred(idx);
      keys[idx] = pred;
      C[idx]->remove(pred);
    }

      // Если у дочернего C [idx] меньше t ключей, исследуем C [idx + 1].
      // Если C [idx + 1] имеет хотя бы t ключей, найти преемника succ для k в поддереве с корнем C [idx + 1]
      // Заменить k на succ
      // Рекурсивно удаляем succ в C [idx + 1]
    else if  (C[idx+1]->n >= t)
    {
      int succ = getSucc(idx);
      keys[idx] = succ;
      C[idx+1]->remove(succ);
    }

      // Если и C [idx], и C [idx + 1] имеют менее t ключей,
      // объединить k и весь C [idx + 1] в C [idx]
      // Теперь C [idx] содержит 2t-1 ключей
      // Освобождаем C [idx + 1] и рекурсивно удаляем k из C [idx]
    else
    {
      merge(idx);
      C[idx]->remove(k);
    }
    return;
  }

  // Функция для получения предшественника ключей [idx]
  int BTreeNode::getPred(int idx)
  {
    // Продолжаем двигаться в крайний правый узел, пока не дойдем до листа
    BTreeNode *cur=C[idx];
    while (!cur->leaf)
      cur = cur->C[cur->n];

    // Возвращаем последний ключ листа
    return cur->keys[cur->n-1];
  }

  int BTreeNode::getSucc(int idx)
  {

    // Продолжаем перемещать крайний левый узел, начиная с C [idx + 1], пока не дойдем до листа
    BTreeNode *cur = C[idx+1];
    while (!cur->leaf)
      cur = cur->C[0];

    // Возвращаем первый ключ листа
    return cur->keys[0];
  }

// Функция для заполнения дочернего C [idx], у которого меньше t-1 ключей
  void BTreeNode::fill(int idx)
  {

    // Если предыдущий дочерний элемент (C [idx-1]) имеет
    // более t-1 ключей, заимствует ключ у этого дочернего элемента
    if (idx!=0 && C[idx-1]->n>=t)
      borrowFromPrev(idx);

      // Если следующий дочерний элемент (C [idx + 1]) имеет более t-1 ключей,
      // заимствует ключ у этого дочернего элемента
    else if (idx!=n && C[idx+1]->n>=t)
      borrowFromNext(idx);

      // Объединить C [idx] с его братом
      // Если C [idx] последний дочерний элемент, объединить его с предыдущим дочерним элементом
      // В противном случае объединить его со следующим братом
    else
    {
      if (idx != n)
        merge(idx);
      else
        merge(idx-1);
    }
    return;
  }

  // Функция для заимствования ключа из C [idx-1] и вставки его в C [idx]
  void BTreeNode::borrowFromPrev(int idx)
  {

    BTreeNode *child=C[idx];
    BTreeNode *sibling=C[idx-1];

    // Последний ключ от C [idx-1] идет вверх до родительского,
    // а ключ [idx-1] от родителя вставляется как первый ключ в C [idx].
    // Таким образом, брат теряет один ключ, а ребенок получает один ключ.

    // Перемещение всех ключей в C [idx] на шаг вперед
    for (int i=child->n-1; i>=0; --i)
      child->keys[i+1] = child->keys[i];

    // Если C [idx] не лист, перемещаем все его дочерние указатели на один шаг вперед
    if (!child->leaf)
    {
      for(int i=child->n; i>=0; --i)
        child->C[i+1] = child->C[i];
    }

    // Устанавливаем первый ключ ребенка равным ключам [idx-1] от текущего узла
    child->keys[0] = keys[idx-1];

    // Перемещение последнего потомка брата как первого потомка C [idx]
    if(!child->leaf)
      child->C[0] = sibling->C[sibling->n];

    // Перемещение ключа от брата к родительскому
    // Это уменьшает количество ключей в сестре
    keys[idx-1] = sibling->keys[sibling->n-1];

    child->n += 1;
    sibling->n -= 1;

    return;
  }

  // Функция, которая заимствует ключ из C [idx + 1] и помещает его в C [idx]
  void BTreeNode::borrowFromNext(int idx)
  {

    BTreeNode *child=C[idx];
    BTreeNode *sibling=C[idx+1];

    // ключи [idx] вставляются как последний ключ в C [idx]
    child->keys[(child->n)] = keys[idx];

    // Первый дочерний элемент сестры вставляется последним в C [idx]
    if (!(child->leaf))
      child->C[(child->n)+1] = sibling->C[0];

    // Первый ключ из родного брата вставляется в keys [idx]
    keys[idx] = sibling->keys[0];

    // Перемещение всех ключей в сестре на один шаг назад
    for (int i=1; i<sibling->n; ++i)
      sibling->keys[i-1] = sibling->keys[i];

    // Перемещение дочерних указателей на один шаг назад
    if (!sibling->leaf)
    {
      for(int i=1; i<=sibling->n; ++i)
        sibling->C[i-1] = sibling->C[i];
    }

    // Увеличение и уменьшение количества ключей C [idx] и C [idx + 1] соответственно
    child->n += 1;
    sibling->n -= 1;

    return;
  }

// Функция для объединения C [idx] с C [idx + 1]
// C [idx + 1] освобождается после слияния
  void BTreeNode::merge(int idx)
  {
    BTreeNode *child = C[idx];
    BTreeNode *sibling = C[idx+1];

    // Извлекаем ключ из текущего узла и вставляем его в (t-1) позицию C [idx]
    child->keys[t-1] = keys[idx];

    // Копирование ключей из C [idx + 1] в C [idx] в конце
    for (int i=0; i<sibling->n; ++i)
      child->keys[i+t] = sibling->keys[i];

    // Копирование дочерних указателей из C [idx + 1] в C [idx]
    if (!child->leaf)
    {
      for(int i=0; i<=sibling->n; ++i)
        child->C[i+t] = sibling->C[i];
    }

    // Перемещение всех ключей после idx в текущем узле на один шаг до -
    // чтобы заполнить пробел, созданный перемещением ключей [idx] в C [idx]
    for (int i=idx+1; i<n; ++i)
      keys[i-1] = keys[i];

    // Перемещение дочерних указателей после (idx + 1) в текущем узле на один шаг до
    for (int i=idx+2; i<=n; ++i)
      C[i-1] = C[i];

    // Обновление количества ключей дочернего и текущего узла
    child->n += sibling->n+1;
    n--;

    // Освобождение памяти, занятой братьями и сестрами
    delete(sibling);
    return;
  }

// Основная функция, которая вставляет новый ключ в это B-дерево
  void BTree::insert(int k)
  {
    // Если дерево пусто
    if (root == NULL)
    {
      // Выделяем память для root
      root = new BTreeNode(t, true);
      root->keys[0] = k;  // Вставить ключ
      root->n = 1;  // Обновить количество ключей в корне
    }
    else // Если дерево не пустое
    {
      // Если корень полон, то дерево растет в высоту
      if (root->n == 2*t-1)
      {
        // Выделяем память для нового корня
        BTreeNode *s = new BTreeNode(t, false);

        // Делаем старый корень дочерним по отношению к новому корню
        s->C[0] = root;

        // Разделить старый корень и переместить 1 ключ в новый корень
        s->splitChild(0, root);

        // У нового корня теперь двое потомков.
        // Решите, у кого из двух детей будет новый ключ
        int i = 0;
        if (s->keys[0] < k)
          i++;
        s->C[i]->insertNonFull(k);

        // Меняем корень
        root = s;
      }
      else  // Если root не заполнен, вызвать insertNonFull для root
        root->insertNonFull(k);
    }
  }

// Служебная функция для вставки нового ключа в этот узел
// Предполагается, что узел должен быть неполным при вызове этой функции
  void BTreeNode::insertNonFull(int k)
  {
    // Инициализируем индекс как индекс самого правого элемента
    int i = n-1;

    // Если это листовой узел
    if (leaf == true)
    {
      // Следующий цикл делает две вещи
      // а) Находит расположение нового ключа, который нужно вставить
      // б) Перемещает все большие клавиши на одну позицию вперед
      while (i >= 0 && keys[i] > k)
      {
        keys[i+1] = keys[i];
        i--;
      }

      // Вставляем новый ключ в найденное место
      keys[i+1] = k;
      n = n+1;
    }
    else // Если этот узел не лист
    {
      // Найдите ребенка, у которого будет новый ключ
      while (i >= 0 && keys[i] > k)
        i--;

      // Посмотрите, полон ли найденный ребенок
      if (C[i+1]->n == 2*t-1)
      {
        // Если ребенок сыт, то разделите его
        splitChild(i+1, C[i+1]);

        // После разделения средний ключ C [i] поднимается вверх,
        // а C [i] разделяется на две части.
        // Посмотрите, у кого из двух будет новый ключ
        if (keys[i+1] < k)
          i++;
      }
      C[i+1]->insertNonFull(k);
    }
  }

// Служебная функция для разделения дочернего y этого узла
// Обратите внимание, что y должен быть заполнен, когда эта функция вызывается
  void BTreeNode::splitChild(int i, BTreeNode *y)
  {
// Создаем новый узел, который будет хранить (t-1) ключи y
    BTreeNode *z = new BTreeNode(y->t, y->leaf);
    z->n = t - 1;

    // Копируем последние (t-1) ключи y в z
    for (int j = 0; j < t-1; j++)
      z->keys[j] = y->keys[j+t];

    // Копируем последние t дочерних элементов y в z
    if (y->leaf == false)
    {
      for (int j = 0; j < t; j++)
        z->C[j] = y->C[j+t];
    }

    // Уменьшаем количество ключей в y
    y->n = t - 1;

    // Поскольку у этого узла будет новый дочерний элемент,
    // создайте пространство для нового дочернего элемента
    for (int j = n; j >= i+1; j--)
      C[j+1] = C[j];

    // Связываем нового потомка с этим узлом
    C[i+1] = z;

    // Ключ y переместится в этот узел.
    // Найдите место нового ключа и переместите
    // все большие ключи на одну позицию вперед.
    for (int j = n-1; j >= i; j--)
      keys[j+1] = keys[j];

    // Копируем средний ключ y в этот узел
    keys[i] = y->keys[t-1];

    // Увеличиваем количество ключей в этом узле
    n = n + 1;
  }

// Функция для обхода всех узлов в поддереве, основанном на этом узле
  void BTreeNode::traverse()
  {
    // Есть n ключей и n + 1 потомков, проходит через n ключей и первые n потомков
    int i;
    for (i = 0; i < n; i++)
    {
      // Если это не лист, то перед печатью ключа [i]
      // пройти по поддереву с корнем дочернего элемента C [i].
      if (leaf == false)
        C[i]->traverse();
      std::cout << " " << keys[i];
    }

    // Распечатываем поддерево с последним потомком
    if (leaf == false)
      C[i]->traverse();
  }

  // Функция для поиска ключа k в поддереве, имеющем корень с этим узлом
  BTreeNode *BTreeNode::search(int k)
  {
    // Находим первый ключ больше или равный k
    int i = 0;
    while (i < n && k > keys[i])
      i++;

    // Если найденный ключ равен k, вернуть этот узел
    if (keys[i] == k)
      return this;

    // Если ключ здесь не найден и это листовой узел
    if (leaf == true)
      return NULL;

    // Переходим к соответствующему потомку
    return C[i]->search(k);
  }

  void BTree::remove(int k)
  {
    if (!root)
    {
      std::cout << "The tree is empty\n";
      return;
    }

    // Вызов функции удаления для root
    root->remove(k);

    // Если у корневого узла 0 ключей, сделаем его первого потомка новым корнем
    // если у него есть потомок, иначе установить root как NULL
    if (root->n==0)
    {
      BTreeNode *tmp = root;
      if (root->leaf)
        root = NULL;
      else
        root = root->C[0];

      // Free the old root
      delete tmp;
    }
    return;
  }

}  // namespace itis